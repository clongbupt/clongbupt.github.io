---
layout: post
category: 云计算
tags: uaa varz  
description: 本文主要是阅读uaa相关源代码，以解决CFV2部署过程中uaa的varz不可用的问题
---

用户账号和鉴权服务API
====

概述
=====

用户账户和鉴权服务(UAA):

* 从CC提出来的一个单独的应用
* 拥有用户账户和鉴权源码
* 通过JSON的方式调用
* 支持标准的协议以向web应用提供单点登录(single sign-on)和权限委派(delegated authorization), 并且JSON API支持CC和CF的团队特性
* 支持APIs和基本的登录和授权(login/approval)的界面
* 支持外部WEB界面的用户账号管理的APIs

大部分的API都是遵照OAuth2/OpenID Connect/SCIM标准


配置参数
====

一些操作模型和可选的特性可以通过配置文件来设置. 通过改变环境变量和系统属性可以设置很多标准化的脚本

* 内部的username/password 鉴权源

	UAA管理一个用户账户数据库. 这些账户可以通过基于密码的鉴权方式被使用, 这个类似于现存的CF用户账户. UAA

* 其他的鉴权源

	其他的标准外部鉴权源也可以被使用. 最通用的是LDAP服务器, 或者一个外部的OpenID提供者. 其他的认证源可以是水平应用管理器, 比如OAuth2或者SAML协议。SAML2支持暂时还不在计划列表中, 但是很快会被开发.

鉴权和授权的认证APIs
===

这一节处理机器之间的联调, 而不是浏览器, 尽管他们中的有些可能有认真用户可以通过浏览器访问的内容. 所有机器的请求都接受JSON格式的Header

`/userinfo` `/check_id`和`/token`这些访问点在`OpenID Connect` 和 `OAuth2`标准中被指定, 并且应该被CF实例的web应用使用, 比如micro, www, support, 但是不能被vmc使用


OAuth范围
===

OAuth2的定义里面有一个scope参数的作为token授权请求的一部分, 该授权包含了一堆的scope变量.

范围变量是完全任意的并且可以被任何资源服务器通过token取得

1. 在客户端注册的时候有可选的步骤，客户端声明它要请求哪一个scopes或者鉴权服务器来限制它可以请求的scopes. 然后鉴权服务器便会检查包含合法scope的token请求.

2. 每一个资源服务器都有一个唯一的ID, 比如一个URI. 并且另一个在客户端注册时可选的部分是提供一个允许资源的列表给询问的客户端. 鉴权服务器将token同允许的资源id绑定, 并且通过`/check_token`的URL来提供信息, 这样资源服务器可以在提供资源前检查它们自己的ID同token的绑定是不是在允许的列表中.

3. 资源ID有scope一些字符, 除非客户端不需要知道这些信息, 这些信息会在鉴权服务器和资源服务器之间交换. 这个文档中的示例使用`scope`参数来标识一个资源服务器. 比如： 一个Cloud Controller实例. 

鉴权码的授权
===

OAuth2定义的实现
干货来了, 重点标注一下
~~~~~~~~~~~~~~~~~~~~

浏览器请求码: `GET /oauth/authorize`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*HTML响应码*

* 请求: `GET /oauth/authorize`
* 请求体: spec中规定的一些参数, 再加上`application/x-www-form-urlencoded`格式的查询模块

	* `response_type=code`
	* `client_id=www`
	* `scope=read write password`
	* `redirect_uri`是可选的, 因为可以预先注册

* 请求头：
	
	* `Cookie:JSESSIONID=ADHGFKHDSJGFGF; Path /` - UAA给客户端的鉴权cookie. 如果用户浏览器没有cookie的话会被跳转到`/login`, 并且最终会跳转到`/oauth/authrize`

* 响应头： location跟spec里面定义的一样, 包含`access_token`, 如果成功的话:

		HTTP/1.1 302 Found
		Location: https://www.cloudfoundry.example.com?code=F45jH

* 响应码:

		302 - Found

非浏览器请求码: `GET /oauth/authorize`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*JSON Response*

如果客户端请求一个JSON的响应(通过`Accept`的header)并且用户还没有认可授权, UAA会发送一个带有一些有用信息的JSON对象, 这些内容可以让用户阅读并且详尽地认可授权.

		{
			"message":"To confirm or deny access POST to the following locations with the parameters requested."
			"scopes":[
				{
					"text":"Access your data with scope 'openid'",
					"code":"scope.openid"
				},
				{
					"text":"Access your 'cloud_controller' resources with scope 'read'",
					"code":"scope.cloud_controller.read"
				}
				...
			],
			"client_id":"idtestapp",
			"redirect_uri":"http://nowhere.com",
			"options":{
				"deny":{
					"location":"https://uaa.cloudfoundry.com/oauth/authorize",
					"value":"false",
					"path":"/oauth/authorize",
					"key":"user_oauth_approval"
				}，
				"confirm":{
					"location":"https://uaa.cloudfoundry.com/oauth/authorize",
					"value":"true",
					"path":"/oauth/authorize",
					"key":"user_oauth_approval"
				}
			}
		}

创建一个用户授权页面最有用的信息是请求的scope列表, 客户端ID和请求跳转URI

客户端包含Token: `POST /oauth/token`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

参见 `oauth2 token endpoint`


管理节点
===

基本概念 `GET /varz`
-------

鉴权是使用携带配置文件中配置的验证信息的HTTP
通过 `varz.username` 和 `varz.password`从`/varz`节点拉取信息

data是通过JMX `MBeanServer` 暴露出的细节信息

更多详细的信息是通过下面的链接提供

* Request `GET /varz`
* 响应体：
	
		{
			"type": "UAA",
			"links": {
				"Users": "http://localhost:8080/uaa/varz/Users",
				"JMImplementtation":
				"http://localhost:8080/uaa/varz/JMImplement",
				"spring.application": "http://localhost:8080/uaa/varz/com.sun.management",
				"Catalina": "http://localhost:8080/uaa/varz/Catalina",
				"env": "http://localhost:8080/uaa/varz/env",
				"java.lang": "http://localhost:8080/uaa/varz/java.lang",
				"java.util.logging": "http://localhost:8080/uaa/varz/java.util.logging"
			},
			"mem": 191734496,
			"memory": {
				"verbose": false,
				"non\_heap\_memory\_usage": {
					"max": 1845493376,
					"committed": 30834688,
					"init": 19136512,
					"used": 30577744
				},
				"object\_pending\_finalization_count": 0,
				"heap\_memory_usage": {
					"max": 9022996648,
					"committed": 84475904,
					"init": 63338494,
					"used": 19173496
				}
			},
			"token_store": {
				"refresh\_token\_count": 0,
				"access\_token\_count": 0,
				"flush_interval": 1000
			},
			"audit_service": {
				"user\_authentication\_count": 0,
				"user\_not\_fount\_count": 0,
				"principal\_authentication\_failure\_count": 1,
				"user\_authentication\_failure\_count": 0
			}
			"spring.profiles.active": []
		}

详细的概念  `GET /varz/{domain}`
----

更多详细的信息可以通过`/varz`后面的link取得

`/varz/env` 链接是高层的JMX的`MBeanServer`域名信息

`/varz/Catalina` 对于对象图中有一些已知的循环, 我们可以避免

* 请求: `GET /varz/{domain}`
* 响应体 (domain=Catalina)

		{
			"global\_request\_processor": {
				"http-8080": {
					"processing_time": 0,
					"max_time": 0,
					"request_count": 0,
					"bytes_sent": 0,
					"bytes_received": 0,
					"error_count": 0,
					"modeler_type": "org.apache.coyote.RequestGroupInfo"
				}
			}


		}


Spring应用的Beans通过`/varz/spring.application`暴露出来



